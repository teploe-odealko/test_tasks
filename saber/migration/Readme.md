# Миграция базы данных

## Задание
Есть база данных и два типа сервисов А и Б:  
•	Сервисы типа А добавляют в базу записи в формате: id, name, status, timestamp.  
•	Сервисы типа Б читают эти данные для агрегации и прочих нужд.

В какой-то момент выясняется, что строковые имена в этих записях занимают слишком много памяти, и при этом часто повторяются. Поэтому целесообразно вынести их в отдельную табличку.

В результате данные должны будут добавляться в следующем формате: id, name_id, status, timestamp. Где name_id внешний ключ к новой таблице с полями: id, name.

Задача заключается в том, что бы составить пошаговый план миграции базы и сервисов на новый формат данных, при этом не разломав работоспособность системы.

ВАЖНО: 
1. Нельзя остановить и обновить все сервисы разом (т.е. нельзя остановить сразу все сервисы типа А, либо все сервисы типа Б, обновление сервисов происходит по одному за раз).
2. В базе данных атомарно можно делать только следующие запросы:
  - добавить колонку
  - удалить колонку
  - переименовать колонку

## Решение

**Если БД поддерживает триггеры.**
1.	Добавляем новую таблицу с именами с полями: id, name
2.	Добавляем колонку name_id в старой таблице, которая пока может принимать значения NULL.
3.	Теперь мы хотим, чтобы в новой таблице оказались все уникальные имена из старой, при том, что в любой момент сервисы типа А могут добавить новое имя. Для того, чтобы не потерять имена, которые могут прийти от сервисов типа А, добавим триггер в бд, который будет срабатывать при добавлении данных этими сервисами и дублировать имена в новую таблицу. И уже после реализации триггера надо написать утилиту, которая добавит в новую таблицу уникальные имена из старой, связав таблицы через внешний ключ в старой таблице (поле name_id)
4.	На этом моменте у нас есть новая таблица с заполненными данными. Изменяем и деплоим сервисы типа Б так, чтобы они читали данные по новой схеме.
5.	Изменяем и деплоим сервисы типа А так, чтобы они записывали данные по новой схеме.
6.	Удаляем триггер
7.	Изменяем колонку name_id так, чтобы она не могла принимать значения null для обеспечения целостности данных (в случае необходимости)
8.	Удаляем колонку name из старой таблицы.

**Если БД не поддерживает триггеры.**  
Вместо шага 3, 5 и 6 будут следующие 
3 - Изменяем и деплоим сервисы типа А, чтобы они добавляли данные как по старой, так и по новой схеме. После этого, надо написать утилиту, которая добавит в новую таблицу уникальные имена из старой, связав таблицы через внешний ключ в старой таблице (поле name_id)  
5 - Изменяем и деплоим сервисы типа А так, чтобы они записывали данные **только** по новой схеме.  
6 -
	

